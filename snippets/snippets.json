{"_G":{"body":"_G(${0:...})","description":"_G","prefix":"_G"},"_VERSION":{"body":"_VERSION(${0:...})","description":"_VERSION","prefix":"_VERSION"},"adc.colse()":{"body":"adc.colse()","description":"关闭adc\r\n返回值：\r\n  无","prefix":"adc.colse()"},"adc.open()":{"body":"adc.open()","description":"打开对应ID的ADC通道\r\n返回值：\r\n1：成功打开adc通道\r\n0：其他\r\n例子：\r\n--adc id\r\nlocal ADC_ID = 0\r\n--打开adc\r\nadc.open(ADC_ID)\r\n","prefix":"adc.open()"},"adc.read()":{"body":"adc.read()","description":"读取原始测量数据和电压值，电压值单位为mv\r\n返回值：\r\nadcValue,原始数据ad值，无效值为0xFFFF。voltValue,电压值，单位为mv，无效值为0xFFFF\r\n例子：\r\n--adcval为number类型，表示adc的原始值，无效值为0xFFFF\r\n--voltval为number类型，表示转换后的电压值，单位为毫伏，无效值为0xFFFF；adc.read接口返回的voltval放大了3倍，所以需要除以3还原成原始电压\r\nlocal adcval,voltval = adc.read(ADC_ID)\r\n","prefix":"adc.read()"},"apn.get_default_apn()":{"body":"apn.get_default_apn()","description":"通过mcc和mnc获取到默认apn\r\n返回值：\r\napn,apn名字\r\nuser,用户名\r\npassword,密码","prefix":"apn.get_default_apn()"},"assert":{"body":"assert(${1:v}${2:[, message]})","description":"assert()","prefix":"assert"},"audiocore.play()":{"body":"audiocore.play()","description":"播放音乐\r\n返回值：\r\n  true:播放成功\r\nfalse:播放失败","prefix":"audiocore.play()"},"audiocore.setchannel()":{"body":"audiocore.setchannel()","description":"设置音频播放通道","prefix":"audiocore.setchannel()"},"audiocore.setloopback()":{"body":"audiocore.setloopback()","description":"设置通道指定的环回测试\r\n返回值：\r\n  1:成功\r\n0:其他","prefix":"audiocore.setloopback()"},"audiocore.setmicvol()":{"body":"audiocore.setmicvol()","description":"设置麦克风音量\r\n返回值：\r\n  1:成功\r\n0:其他","prefix":"audiocore.setmicvol()"},"audiocore.setvol()":{"body":"audiocore.setvol()","description":"设置音频播放音量大小\r\n返回值：\r\n  1:成功\r\n0:其他","prefix":"audiocore.setvol()"},"audiocore.stop()":{"body":"audiocore.stop()","description":"停掉正在播放的音频\r\n返回值：\r\n  无","prefix":"audiocore.stop()"},"bit.arshift()":{"body":"bit.arshift()","description":"算数右移\r\n返回值：\r\n  算术右移之后的结果\r\n例子：\r\nprint(bit.arshift(2,2))--算数右移，左边添加的数与符号有关，输出为0\r\n","prefix":"bit.arshift()"},"bit.band()":{"body":"bit.band()","description":"与运算，等价于Ｃ语言中的val1 & val2 & ... & valn\r\n返回值：\r\n  与运算之后的结果\r\n例子：\r\nprint(bit.band(1,1))--与,--输出1\r\n","prefix":"bit.band()"},"bit.bit()":{"body":"bit.bit()","description":"左移运算，等价于C语言中的1 << position\r\n返回值：\r\n  移位运算后的值\r\n例子：\r\nprint(bit.bit(2))--参数是位数，作用是1向左移动两位，打印出4\r\n","prefix":"bit.bit()"},"bit.bnot()":{"body":"bit.bnot()","description":"取反，等价于C语言中的~\r\n返回值：\r\n  取反之后的值\r\n例子：\r\nprint(bit.bnot(5))--按位取反，输出-6\r\n","prefix":"bit.bnot()"},"bit.bor()":{"body":"bit.bor()","description":"或运算，等价于C里面的val1 | val2 | ... | valn\r\n返回值：\r\n  或运算之后的结果\r\n例子：\r\nprint(bit.bor(1,2))--或，--输出3\r\n","prefix":"bit.bor()"},"bit.bxor()":{"body":"bit.bxor()","description":"异或运算，等价于C语言中的val1 ^ val2 ^ ... ^ valn\r\n返回值：\r\n  异或运算之后的结果\r\n例子：\r\nprint(bit.bxor(1,2))--异或,相同为0，不同为1\r\n","prefix":"bit.bxor()"},"bit.clear()":{"body":"bit.clear()","description":"置0\r\n返回值：\r\n  置0之后的值\r\n例子：\r\nprint(bit.clear(5,0,2)) --在相应的位置置0，打印0\r\n","prefix":"bit.clear()"},"bit.isclear()":{"body":"bit.isclear()","description":"测试位数是否被置0\r\n返回值：\r\n  true:该位被置0\r\nfalse:其他\r\n例子：\r\nprint(bit.isclear(5,0))--与上面的相反\r\nprint(bit.isclear(5,1))\r\nprint(bit.isclear(5,2))\r\nprint(bit.isclear(5,3))\r\n","prefix":"bit.isclear()"},"bit.isset()":{"body":"bit.isset()","description":"测试位数是否被置1\r\n返回值：\r\n  true:该位被置1\r\nfalse:其他\r\n例子：\r\nprint(bit.isset(5,0))--第一个参数是是测试数字，第二个是测试位置。从右向左数0到7。是1返回true，否则返回false，该返回true\r\nprint(bit.isset(5,1))--打印false\r\nprint(bit.isset(5,2))--打印true\r\nprint(bit.isset(5,3))--返回返回false\r\n","prefix":"bit.isset()"},"bit.lshift()":{"body":"bit.lshift()","description":"逻辑左移，等价于C语言中的value << shift\r\n返回值：\r\n  逻辑左移之后的结果\r\n例子：\r\nprint(bit.lshift(1,2))--逻辑左移，“100”，输出为4\r\n","prefix":"bit.lshift()"},"bit.rshift()":{"body":"bit.rshift()","description":"逻辑右移，等价于C语言中的value >> shift\r\n返回值：\r\n  逻辑右移之后的结果\r\n例子：\r\nprint(bit.rshift(4,2))--逻辑右移，“001”，输出为1\r\n","prefix":"bit.rshift()"},"bit.set()":{"body":"bit.set()","description":"置1\r\n返回值：\r\n  置1之后的值\r\n例子：\r\nprint(bit.set(0,0,1,2,3))--在相应的位数置1，打印15\r\n","prefix":"bit.set()"},"collectgarbage":{"body":"collectgarbage(${1:[opt]}${2:[, arg]})","description":"collectgarbage()","prefix":"collectgarbage"},"coroutine.create":{"body":"coroutine.create( ${1:function} )","description":"coroutine.create","prefix":"coroutine.create"},"coroutine.isyieldable":{"body":"coroutine.isyieldable( )","description":"coroutine.isyieldable","prefix":"coroutine.isyieldable"},"coroutine.resume":{"body":"coroutine.resume( ${1:co}${2:[, val1, ···]} )","description":"coroutine.resume","prefix":"coroutine.resume"},"coroutine.running":{"body":"coroutine.running( )","description":"coroutine.running","prefix":"coroutine.running"},"coroutine.status":{"body":"coroutine.status( ${1:co} )","description":"coroutine.status","prefix":"coroutine.status"},"coroutine.wrap":{"body":"coroutine.wrap( ${1:function} )","description":"coroutine.wrap","prefix":"coroutine.wrap"},"coroutine.yield":{"body":"coroutine.yield( ${1:...} )","description":"coroutine.yield","prefix":"coroutine.yield"},"crypto.aes_encrypt()":{"body":"crypto.aes_encrypt()","description":"aes算法（参考http://tool.chacuo.net/cryptaes）\r\n返回值：\r\n  已加密的字符串\r\n例子：\r\n--下面示例为LuaTask的，如果需要LuaScript的，请参考LuaScript crypto demo\r\nlocal originStr = \"AES128 ECB ZeroPadding test\"\r\n--加密模式：ECB；填充方式：ZeroPadding；密钥：1234567890123456；密钥长度：128 bit\r\nlocal encodeStr = crypto.aes_encrypt(\"ECB\",\"ZERO\",originStr,\"1234567890123456\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"ZERO\",encodeStr,\"1234567890123456\"))\r\noriginStr = \"AES128 ECB Pkcs5Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs5Padding；密钥：1234567890123456；密钥长度：128 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS5\",originStr,\"1234567890123456\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS5\",encodeStr,\"1234567890123456\"))\r\noriginStr = \"AES128 ECB Pkcs7Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs7Padding；密钥：1234567890123456；密钥长度：128 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS7\",originStr,\"1234567890123456\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS7\",encodeStr,\"1234567890123456\"))\r\noriginStr = \"AES192 ECB ZeroPadding test\"\r\n--加密模式：ECB；填充方式：ZeroPadding；密钥：123456789012345678901234；密钥长度：192 bit\r\nlocal encodeStr = crypto.aes_encrypt(\"ECB\",\"ZERO\",originStr,\"123456789012345678901234\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"ZERO\",encodeStr,\"123456789012345678901234\"))\r\noriginStr = \"AES192 ECB Pkcs5Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs5Padding；密钥：123456789012345678901234；密钥长度：192 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS5\",originStr,\"123456789012345678901234\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS5\",encodeStr,\"123456789012345678901234\"))\r\noriginStr = \"AES192 ECB Pkcs7Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs7Padding；密钥：123456789012345678901234；密钥长度：192 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS7\",originStr,\"123456789012345678901234\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS7\",encodeStr,\"123456789012345678901234\"))\r\noriginStr = \"AES256 ECB ZeroPadding test\"\r\n--加密模式：ECB；填充方式：ZeroPadding；密钥：12345678901234567890123456789012；密钥长度：256 bit\r\nlocal encodeStr = crypto.aes_encrypt(\"ECB\",\"ZERO\",originStr,\"12345678901234567890123456789012\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"ZERO\",encodeStr,\"12345678901234567890123456789012\"))\r\noriginStr = \"AES256 ECB Pkcs5Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs5Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS5\",originStr,\"12345678901234567890123456789012\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS5\",encodeStr,\"12345678901234567890123456789012\"))\r\noriginStr = \"AES256 ECB Pkcs7Padding test\"\r\n--加密模式：ECB；填充方式：Pkcs7Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit\r\nencodeStr = crypto.aes_encrypt(\"ECB\",\"PKCS7\",originStr,\"12345678901234567890123456789012\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"ECB\",\"PKCS7\",encodeStr,\"12345678901234567890123456789012\"))\r\noriginStr = \"AES128 CBC ZeroPadding test\"\r\n--加密模式：CBC；填充方式：ZeroPadding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CBC\",\"ZERO\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"ZERO\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CBC Pkcs5Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs5Padding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS5\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS5\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CBC Pkcs7Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs7Padding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS7\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS7\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES192 CBC ZeroPadding test\"\r\n--加密模式：CBC；填充方式：ZeroPadding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CBC\",\"ZERO\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"ZERO\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CBC Pkcs5Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs5Padding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS5\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS5\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CBC Pkcs7Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs7Padding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS7\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS7\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES256 CBC ZeroPadding test\"\r\n--加密模式：CBC；填充方式：ZeroPadding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CBC\",\"ZERO\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"ZERO\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\noriginStr = \"AES256 CBC Pkcs5Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs5Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS5\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS5\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\noriginStr = \"AES256 CBC Pkcs7Padding test\"\r\n--加密模式：CBC；填充方式：Pkcs7Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CBC\",\"PKCS7\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CBC\",\"PKCS7\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\noriginStr = \"AES128 CTR ZeroPadding test\"\r\n--加密模式：CTR；填充方式：ZeroPadding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CTR\",\"ZERO\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"ZERO\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CTR Pkcs5Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs5Padding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS5\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS5\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CTR Pkcs7Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs7Padding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS7\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS7\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES128 CTR NonePadding test\"\r\n--加密模式：CTR；填充方式：NonePadding；密钥：1234567890123456；密钥长度：128 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"NONE\",originStr,\"1234567890123456\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"NONE\",encodeStr,\"1234567890123456\",\"1234567890666666\"))\r\noriginStr = \"AES192 CTR ZeroPadding test\"\r\n--加密模式：CTR；填充方式：ZeroPadding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CTR\",\"ZERO\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"ZERO\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CTR Pkcs5Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs5Padding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS5\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS5\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CTR Pkcs7Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs7Padding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS7\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS7\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES192 CTR NonePadding test\"\r\n--加密模式：CTR；填充方式：NonePadding；密钥：123456789012345678901234；密钥长度：192 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"NONE\",originStr,\"123456789012345678901234\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"NONE\",encodeStr,\"123456789012345678901234\",\"1234567890666666\"))\r\noriginStr = \"AES256 CTR ZeroPadding test\"\r\n--加密模式：CTR；填充方式：ZeroPadding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nlocal encodeStr = crypto.aes_encrypt(\"CTR\",\"ZERO\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"ZERO\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\noriginStr = \"AES256 CTR Pkcs5Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs5Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS5\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS5\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\n\r\noriginStr = \"AES256 CTR Pkcs7Padding test\"\r\n--加密模式：CTR；填充方式：Pkcs7Padding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"PKCS7\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"PKCS7\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\n\r\noriginStr = \"AES256 CTR NonePadding test\"\r\n--加密模式：CTR；填充方式：NonePadding；密钥：12345678901234567890123456789012；密钥长度：256 bit；偏移量：1234567890666666\r\nencodeStr = crypto.aes_encrypt(\"CTR\",\"NONE\",originStr,\"12345678901234567890123456789012\",\"1234567890666666\")\r\nprint(originStr,\"encrypt\",string.toHex(encodeStr))\r\nlog.info(\"testCrypto.decrypt\",crypto.aes_decrypt(\"CTR\",\"NONE\",encodeStr,\"12345678901234567890123456789012\",\"1234567890666666\"))\r\n","prefix":"crypto.aes_encrypt()"},"crypto.base64_decode()":{"body":"crypto.base64_decode()","description":"base64解密\r\n返回值：\r\n  解密后的数据\r\n例子：\r\nprint(\"base64_decode\",crypto.base64_decode(encodestr,slen(encodestr)))\r\n-- base64_decode\t123456\r\n","prefix":"crypto.base64_decode()"},"crypto.base64_encode()":{"body":"crypto.base64_encode()","description":"base64加密\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"123456\"\r\nlocal encodestr = crypto.base64_encode(originstr,slen(originstr))\r\nprint(\"base64_encode\",encodestr)\r\n--base64_encode\tMTIzNDU2\r\n","prefix":"crypto.base64_encode()"},"crypto.crc16()":{"body":"crypto.crc16()","description":"CRC16校验算法\r\n返回值：\r\n  校验计算结果\r\n例子：\r\nlocal originStr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"testCrypto.crc16_MODBUS\",string.format(\"%04X\",crypto.crc16(\"MODBUS\",originStr)))\r\nprint(\"testCrypto.crc16_IBM\",string.format(\"%04X\",crypto.crc16(\"IBM\",originStr)))\r\nprint(\"testCrypto.crc16_X25\",string.format(\"%04X\",crypto.crc16(\"X25\",originStr)))\r\nprint(\"testCrypto.crc16_MAXIM\",string.format(\"%04X\",crypto.crc16(\"MAXIM\",originStr)))\r\nprint(\"testCrypto.crc16_USB\",string.format(\"%04X\",crypto.crc16(\"USB\",originStr)))\r\nprint(\"testCrypto.crc16_CCITT\",string.format(\"%04X\",crypto.crc16(\"CCITT\",originStr)))\r\nprint(\"testCrypto.crc16_CCITT-FALSE\",string.format(\"%04X\",crypto.crc16(\"CCITT-FALSE\",originStr)))\r\nprint(\"testCrypto.crc16_XMODEM\",string.format(\"%04X\",crypto.crc16(\"XMODEM\",originStr)))\r\nprint(\"testCrypto.crc16_DNP\",string.format(\"%04X\",crypto.crc16(\"DNP\",originStr)))\r\n","prefix":"crypto.crc16()"},"crypto.crc32()":{"body":"crypto.crc32()","description":"CRC32校验算法\r\n返回值：\r\n  校验计算结果\r\n例子：\r\nlocal originstr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"crc32\",string.format(\"%08X\",crypto.crc32(originstr,slen(originstr))))\r\n--crc32\t2FC153F9\r\n","prefix":"crypto.crc32()"},"crypto.flow_md5()":{"body":"crypto.flow_md5()","description":"流式md5算法\r\n返回值：\r\n  无\r\n例子：\r\nlocal fmd5Obj=crypto.flow_md5()\r\nlocal testTable={\"lqlq666lqlq946\",\"07946lq94607946\",\"lq54075407540707946\"}\r\nfor i=1, #(testTable) do\r\n    fmd5Obj:update(testTable[i])\r\nend\r\nprint(\"testCrypto.flowMd5Test\",fmd5Obj:hexdigest())\r\n","prefix":"crypto.flow_md5()"},"crypto.hmac_md5()":{"body":"crypto.hmac_md5()","description":"hmac_md5算法测试\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"asdasdsadas\"\r\nlocal signkey = \"123456\"\r\nprint(\"hmac_md5\",crypto.hmac_md5(originstr,slen(originstr),signkey,slen(signkey)))\r\n-- hmac_md5\t38A7B18DC5F6543849DC49F06FADE3CC\r\n","prefix":"crypto.hmac_md5()"},"crypto.hmac_sha1()":{"body":"crypto.hmac_sha1()","description":"hmac_sha1算法\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"asdasdsadasweqcdsjghjvcb\"\r\nlocal signkey = \"12345689012345\"\r\nprint(\"hmac_sha1\",crypto.hmac_sha1(originstr,slen(originstr),signkey,slen(signkey)))\r\n--hmac_sha1\tE3BB109BA59AF6A1F677157E8EC6B21349B9220F\r\n","prefix":"crypto.hmac_sha1()"},"crypto.md5()":{"body":"crypto.md5()","description":"md5算法，支持计算文件的md5值\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"md5\",crypto.md5(originstr,slen(originstr)))\r\n--md5\t235B69FBC9E75C4FD5E8C59F9CB16500\r\n","prefix":"crypto.md5()"},"crypto.sha1()":{"body":"crypto.sha1()","description":"sha1算法\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originstr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"sha1\",crypto.sha1(originstr,slen(originstr)))\r\n-- sha1\t16EBE919119B9B54C8AF6B4F2A09C18B6B6D8218\r\n","prefix":"crypto.sha1()"},"crypto.sha256()":{"body":"crypto.sha256()","description":"sha256算法\r\n返回值：\r\n  加密后的数据\r\n例子：\r\nlocal originStr = \"sdfdsfdsfdsffdsfdsfsdfs1234\"\r\nprint(\"testCrypto.sha256\",crypto.sha256(originStr))\r\n","prefix":"crypto.sha256()"},"crypto.xxtea_encrypt()":{"body":"crypto.xxtea_encrypt()","description":"xxtea加密算法\r\n返回值：\r\n  加密/解密数据\r\n例子：\r\nlocal text = \"Hello World!\";\r\nlocal key = \"07946\";\r\nlocal encrypt_data = crypto.xxtea_encrypt(text, key);\r\nprint(\"testCrypto.xxteaTest\",\"xxtea_encrypt:\"..encrypt_data)\r\nlocal decrypt_data = crypto.xxtea_decrypt(encrypt_data, key);\r\nprint(\"testCrypto.xxteaTest\",\"decrypt_data:\"..decrypt_data)\r\n","prefix":"crypto.xxtea_encrypt()"},"debug.debug":{"body":"debug.debug()","description":"debug.debug ()","prefix":"debug.debug"},"debug.getfenv":{"body":"debug.getfenv(${0:...})","description":"debug.getfenv (o)","prefix":"debug.getfenv"},"debug.gethook":{"body":"debug.gethook( ${1:[thread]} )","description":"debug.gethook ([thread])","prefix":"debug.gethook"},"debug.getinfo":{"body":"debug.getinfo( ${1:[thread],}${2:f}${3:[, what]} )","description":"debug.getinfo ([thread,] f [, what])","prefix":"debug.getinfo"},"debug.getlocal":{"body":"debug.getlocal( ${1:[thread],}${2:f}${3:[, local]} )","description":"debug.getlocal ([thread,] f, local)","prefix":"debug.getlocal"},"debug.getmetatable":{"body":"debug.getmetatable( ${1:value} )","description":"debug.getmetatable (value)","prefix":"debug.getmetatable"},"debug.getregistry":{"body":"debug.getregistry()","description":"debug.getregistry ()","prefix":"debug.getregistry"},"debug.getupvalue":{"body":"debug.getupvalue( ${1:f}, ${2:up} )","description":"debug.getupvalue (f, up)","prefix":"debug.getupvalue"},"debug.getuservalue":{"body":"debug.getuservalue(${0:...})","description":"debug.getuservalue (u)","prefix":"debug.getuservalue"},"debug.getuservalue ":{"body":"debug.getuservalue ( ${1:u} )","description":"debug.getuservalue (u)","prefix":"debug.getuservalue "},"debug.setfenv":{"body":"debug.setfenv(${0:...})","description":"debug.setfenv (object, table)","prefix":"debug.setfenv"},"debug.sethook":{"body":"debug.sethook( ${1:[thead,]}${2:hook}, ${3:mask}${4:[, count]} )","description":"debug.sethook ([thread,] hook, mask [, count])","prefix":"debug.sethook"},"debug.setlocal":{"body":"debug.setlocal( ${1:[thead,]}${2:level}, ${3:local}, ${4:value} )","description":"debug.setlocal ([thread,] level, local, value)","prefix":"debug.setlocal"},"debug.setmetatable":{"body":"debug.setmetatable( ${1:value}, ${2:table} )","description":"debug.setmetatable (value, table)","prefix":"debug.setmetatable"},"debug.setupvalue":{"body":"debug.setupvalue( ${1:f}, ${2:up}, ${3:value} )","description":"debug.setupvalue (f, up, value)","prefix":"debug.setupvalue"},"debug.setuservalue":{"body":"debug.setuservalue( ${1:udata}, ${2:value} )","description":"debug.setuservalue (udata, value)","prefix":"debug.setuservalue"},"debug.traceback":{"body":"debug.traceback( ${1:[thread,]}${2:[message]}${3:[, level]} )","description":"debug.traceback ([thread,] [message [, level]])","prefix":"debug.traceback"},"debug.upvalueid":{"body":"debug.upvalueid( ${1:f}, ${2:n})","description":"debug.upvalueid (f, n)","prefix":"debug.upvalueid"},"debug.upvaluejoin":{"body":"debug.upvaluejoin( ${1:f1}, ${2:n1}, ${3:f2}, ${4:n2} )","description":"debug.upvaluejoin (f1, n1, f2, n2)","prefix":"debug.upvaluejoin"},"disp.clear()":{"body":"disp.clear()","description":"清除缓冲区内容，注意不会刷新到屏幕上，只有在update时才会执行刷屏动作\r\n返回值：\r\n  无","prefix":"disp.clear()"},"disp.drawrect()":{"body":"disp.drawrect()","description":"绘制矩形，并且填充颜色。填充色可以自行设置也可不填充颜色值格式RGB565。\r\n返回值：\r\n  无","prefix":"disp.drawrect()"},"disp.getlcdinfo()":{"body":"disp.getlcdinfo()","description":"获取LCD分辨率的宽度和高度(单位是像素)\r\n返回值：\r\n  WIDTH ：宽度\r\n","prefix":"disp.getlcdinfo()"},"disp.init()":{"body":"disp.init()","description":"初始化显示接口语法\r\n返回值：\r\n  无","prefix":"disp.init()"},"disp.loadfont()":{"body":"disp.loadfont()","description":"加载字体\r\n返回值：\r\n  fontid-返回加载后的字体id 用于setfont设置字体","prefix":"disp.loadfont()"},"disp.putimage()":{"body":"disp.putimage()","description":"在坐标(x,y)处显示图片，目前仅支持bmp和png格式，这个接口只会将显示数据写到缓冲区，只有在执行了update了以后才会真正的刷屏。最后面的四个参数是规定了从file中截取某一部分区域\r\n返回值：\r\n  无","prefix":"disp.putimage()"},"disp.putqrcode()":{"body":"disp.putqrcode()","description":"显示二维码\r\n返回值：\r\n  无","prefix":"disp.putqrcode()"},"disp.puttext()":{"body":"disp.puttext()","description":"显示字符串\r\n返回值：\r\n  无\r\n例子：\r\ndisp.puttext(\"欢迎使用Luat\",16,0) --从坐标16,0位置开始显示\"欢迎使用Luat\"\r\n","prefix":"disp.puttext()"},"disp.setbkcolor()":{"body":"disp.setbkcolor()","description":"设置背景色\r\n返回值：\r\n  无","prefix":"disp.setbkcolor()"},"disp.setcolor()":{"body":"disp.setcolor()","description":"设置前景色\r\n返回值：\r\n  无","prefix":"disp.setcolor()"},"disp.setfont()":{"body":"disp.setfont()","description":"设置字体\r\n返回值：\r\n  oldfontid-返回旧的字体id","prefix":"disp.setfont()"},"disp.sleep()":{"body":"disp.sleep()","description":"休眠显示模块","prefix":"disp.sleep()"},"disp.update()":{"body":"disp.update()","description":"将缓冲区内容刷新到屏幕上\r\n返回值：\r\n  无","prefix":"disp.update()"},"dofile":{"body":"dofile(${1:[filename]})","description":"dofile ([filename])","prefix":"dofile"},"elif":{"body":"else if ${1:condition} then\n\t${0:-- body}\n","description":"elif","prefix":"elif"},"error":{"body":"error(${0:...})","description":"error (message [, level])","prefix":"error"},"file:close":{"body":"file:close(${0:...})","description":"file:close ()","prefix":"file:close"},"file:close()":{"body":"file:close()","description":"关闭文件句柄\r\n返回值：\r\n  无","prefix":"file:close()"},"file:flush":{"body":"file:flush(${0:...})","description":"file:flush ()","prefix":"file:flush"},"file:flush()":{"body":"file:flush()","description":"向文件写入缓冲中的所有数据\r\n返回值：\r\n  无","prefix":"file:flush()"},"file:lines":{"body":"file:lines(${0:...})","description":"file:lines ()","prefix":"file:lines"},"file:read":{"body":"file:read(${0:...})","description":"file:read (...)","prefix":"file:read"},"file:read()":{"body":"file:read()","description":"读文件file， 指定的格式决定了要读什么。\r\n返回值：\r\n  对于每种格式，函数返回读出的字符对应的字符串或数字。 若不能以该格式对应读出数据则返回nil\r\n例子：\r\nlocal file = io.open(\"test.txt\", \"r\")\r\nprint(file:read(\"*l\"))  --this is test 1\r\nprint(file:read(\"*n\"))  --nil\r\nprint(file:read(2))  --th\r\n","prefix":"file:read()"},"file:seek":{"body":"file:seek(${0:...})","description":"file:seek ([whence] [, offset])","prefix":"file:seek"},"file:seek()":{"body":"file:seek()","description":"设置和获取当前文件位置。\r\n返回值：\r\n  成功则返回最终的文件位置(按字节),失败则返回nil加错误信息\r\n例子：\r\nlocal file = io.open(\"test.txt\", \"r+\")\r\nprint(file:seek(\"end\"))\t\t--30\r\nprint(file:seek(\"set\"))\t\t--0\r\nprint(file:seek())\t        --0\r\nprint(file:seek(\"cur\", 10))\t\t--10\r\nprint(file:seek(\"cur\"))\t\t--10\r\nprint(file:read(1))\t\t\t--s\r\nprint(file:seek(\"cur\"))\t\t--11\r\nfile:close()\r\n","prefix":"file:seek()"},"file:setvbuf":{"body":"file:setvbuf(${0:...})","description":"file:setvbuf (mode [, size])","prefix":"file:setvbuf"},"file:write":{"body":"file:write(${0:...})","description":"file:write (...)","prefix":"file:write"},"file:write ()":{"body":"file:write ()","description":"将参数的值逐个写入file。\r\n返回值：\r\n  成功时，函数返回 file。 否则返回nil加错误描述字符串。","prefix":"file:write ()"},"for":{"body":"for ${1:i}=${2:1},${3:10} do\n\t${0:print(i)}\nend","description":"for i=1,10","prefix":"for"},"fori":{"body":"for ${1:i},${2:v} in ipairs(${3:table_name}) do\n\t${0:print(i,v)}\nend","description":"for i,v in ipairs()","prefix":"fori"},"forp":{"body":"for ${1:k},${2:v} in pairs(${3:table_name}) do\n\t${0:print(k,v)}\nend","description":"for k,v in pairs()","prefix":"forp"},"fun":{"body":"function ${1:function_name}( ${2:...} )\n\t${0:-- body}\nend","description":"function","prefix":"fun"},"function":{"body":"function ${1:function_name}( ${2:...} )\n\t${0:-- body}\nend","description":"function","prefix":"function"},"getfenv":{"body":"getfenv(${0:...})","description":"getfenv ([f])","prefix":"getfenv"},"getmetatable":{"body":"getmetatable(${1:object})","description":"getmetatable (object)","prefix":"getmetatable"},"i2c.close()":{"body":"i2c.close()","description":"关闭 I2C 接口\r\n返回值：\r\n  无","prefix":"i2c.close()"},"i2c.read()":{"body":"i2c.read()","description":"读取指定寄存器地址 reg 的数据内容\r\n返回值：\r\n  返回读取的数据，二进制数据会包含非可见字符，请使用 string.byte 打印数据流\r\n例子：\r\n--从从设备的寄存器地址cmd[i]中读1字节的数据，并且打印出来\r\n    local cmd,i = {0x1B,0x00,0x6A,0x01,0x1E,0x20,0x21,0x04,0x1B,0x00,0x1B,0xDA,0x1B,0xDA}\r\n    for i=1,#cmd,2 do\r\n        --向从设备的寄存器地址cmd[i]中写1字节的数据cmd[i+1]\r\n        i2c.write(i2cid,cmd[i],cmd[i+1])\r\n        --从从设备的寄存器地址cmd[i]中读1字节的数据，并且打印出来\r\n        print(\"testI2c.init1\",string.format(\"%02X\",cmd[i]),string.toHex(i2c.read(i2cid,cmd[i],1)))\r\n    end\r\n","prefix":"i2c.read()"},"i2c.recv()":{"body":"i2c.recv()","description":"向从设备读取数据\r\n返回值：\r\n  返回读取的数据，二进制数据会包含非可见字符，请使用 string.byte 打印数据流\r\n例子：\r\n--向从设备i2cslaveaddr发送寄存器地址cmd[i]\r\ni2c.send(i2cid,i2cslaveaddr,cmd[i])\r\n--读取从设备i2cslaveaddr寄存器内的1个字节的数据，并且打印出来\r\nprint(\"testI2c.init\",string.format(\"%02X\",cmd[i]),string.toHex(i2c.recv(i2cid,i2cslaveaddr,1)))\r\n","prefix":"i2c.recv()"},"i2c.send()":{"body":"i2c.send()","description":"向从设备写数据\r\n返回值：\r\n  传输成功的字节数\r\n例子：\r\nlocal cmd,i = {0x1B,0x00,0x6A,0x01,0x1E,0x20,0x21,0x04,0x1B,0x00,0x1B,0xDA,0x1B,0xDA}\r\nfor i=1,#cmd,2 do\r\n  --向从设备i2cslaveaddr发送寄存器地址cmd[i]\r\n  i2c.send(i2cid,i2cslaveaddr,cmd[i])\r\n  --向从设备i2cslaveaddr发送要写入从设备寄存器内的数据cmd[i+1]\r\n  i2c.send(i2cid,i2cslaveaddr,cmd[i+1])\r\nend\r\n","prefix":"i2c.send()"},"i2c.setup()":{"body":"i2c.setup()","description":"打开i2c接口\r\n返回值：\r\n  可以根据返回的频率值判断是否成功打开 i2c\r\n例子：\r\n--使用i2c.send和i2c.recv的setup\r\nif i2c.setup(i2cid,i2c.SLOW) ~= i2c.SLOW then\r\n  print(\"init fail\")\r\n  return\r\nend\r\n\r\n--使用i2c.write和i2c.read的setup\r\nif i2c.setup(i2cid,i2c.SLOW,i2cslaveaddr) ~= i2c.SLOW then\r\n  print(\"init1 fail\")\r\n  return\r\nend\r\n","prefix":"i2c.setup()"},"i2c.write()":{"body":"i2c.write()","description":"往指定的寄存器地址 reg 传输数据\r\n返回值：\r\n  传输成功的字节数\r\n例子：\r\nlocal cmd,i = {0x1B,0x00,0x6A,0x01,0x1E,0x20,0x21,0x04,0x1B,0x00,0x1B,0xDA,0x1B,0xDA}\r\nfor i=1,#cmd,2 do\r\n  --向从设备的寄存器地址cmd[i]中写1字节的数据cmd[i+1]\r\n  i2c.write(i2cid,cmd[i],cmd[i+1])\r\nend\r\n","prefix":"i2c.write()"},"if":{"body":"if ${1:condition} then\n\t${0:-- body}\nend","description":"if","prefix":"if"},"ifel":{"body":"if ${1:condition} then\n\t${2:-- body}\nelse\n\t${0:-- body}\nend","description":"ifel","prefix":"ifel"},"io.close":{"body":"io.close(${0:...})","description":"io.close ([file])","prefix":"io.close"},"io.flush":{"body":"io.flush(${0:...})","description":"io.flush ()","prefix":"io.flush"},"io.input":{"body":"io.input(${0:...})","description":"io.input ([file])","prefix":"io.input"},"io.lines":{"body":"io.lines(${0:...})","description":"io.lines ([filename])","prefix":"io.lines"},"io.open":{"body":"io.open(${0:...})","description":"io.open (filename [, mode])","prefix":"io.open"},"io.open()":{"body":"io.open()","description":"这个函数用字符串mode 指定的模式打开一个文件。\r\n返回值：\r\n  返回新的文件句柄。 当出错时，返回 nil加错误消息。\r\n例子：\r\nfile = io.open(\"test.lua\", \"r\")\r\n","prefix":"io.open()"},"io.output":{"body":"io.output(${0:...})","description":"io.output ([file])","prefix":"io.output"},"io.popen":{"body":"io.popen(${0:...})","description":"io.popen (prog [, mode])","prefix":"io.popen"},"io.read":{"body":"io.read(${0:...})","description":"io.read (...)","prefix":"io.read"},"io.tmpfile":{"body":"io.tmpfile(${0:...})","description":"io.tmpfile ()","prefix":"io.tmpfile"},"io.type":{"body":"io.type(${0:...})","description":"io.type (obj)","prefix":"io.type"},"io.write":{"body":"io.write(${0:...})","description":"io.write (...)","prefix":"io.write"},"ipairs":{"body":"ipairs(${0:...})","description":"ipairs (t)","prefix":"ipairs"},"json.decode()":{"body":"json.decode()","description":"json解析\r\n返回值：\r\n  解析内容，table类型\r\n解析结果，true为成功，false为失败\r\n错误信息\r\n例子：\r\n-- 正确json字符串\r\nlocal wrongOrigin = \"{\\\":\\\"VALUE3\\\",\\\"KEY4\\\":\\\"VALUE4\\\",\\\"KEY2\\\":\\\"VALUE2\\\",\\\"KEY1\\\":\\\"VALUE1\\\",\\\"KEY5\\\":{\\\"KEY5_2\\\":\\\"VALU5_2\\\",\\\"KEY5_1\\\":\\\"VALU5_1\\\"},\\\"KEY6\\\":[1,2,3]}\"\r\nlocal origin = \"{\\\"KEY3\\\":\\\"VALUE3\\\",\\\"KEY4\\\":\\\"VALUE4\\\",\\\"KEY2\\\":\\\"VALUE2\\\",\\\"KEY1\\\":\\\"VALUE1\\\",\\\"KEY5\\\":{\\\"KEY5_2\\\":\\\"VALU5_2\\\",\\\"KEY5_1\\\":\\\"VALU5_1\\\"},\\\"KEY6\\\":[1,2,3]}\"\r\nlocal tjsondata,result,errinfo = json.decode(origin)\r\nif result then\r\n    print(tjsondata[\"KEY1\"])\r\n    print(tjsondata[\"KEY2\"])\r\n    print(tjsondata[\"KEY3\"])\r\n    print(tjsondata[\"KEY4\"])\r\n    print(tjsondata[\"KEY5\"][\"KEY5_1\"],tjsondata[\"KEY5\"][\"KEY5_2\"])\r\n    print(tjsondata[\"KEY6\"][1],tjsondata[\"KEY6\"][2],tjsondata[\"KEY6\"][3])\r\nelse\r\n\tprint(\"json.decode error\",errinfo)\r\nend\r\n--origin：正确输出\r\n--wrongOrigin：json.decode error\tExpected colon but found invalid token at character 5\r\n","prefix":"json.decode()"},"json.encode()":{"body":"json.encode()","description":"json编译\r\n返回值：\r\n  json格式字符串\r\n例子：\r\nlocal torigin =\r\n{\r\n    KEY1 = \"VALUE1\",\r\n    KEY2 = \"VALUE2\",\r\n    KEY3 = \"VALUE3\",\r\n    KEY4 = \"VALUE4\",\r\n    KEY5 = {KEY5_1=\"VALU5_1\",KEY5_2=\"VALU5_2\"},\r\n    KEY6 = {1,2,3},\r\n}\r\n\r\nlocal jsondata = json.encode(torigin)\r\n--[[\r\n{\"KEY3\":\"VALUE3\",\"KEY4\":\"VALUE4\",\"KEY2\":\"VALUE2\",\"KEY1\":\"VALUE1\",\"KEY5\":{\"KEY5_2\":\"VALU5_2\",\"KEY5_1\":\"VALU5_1\"}},\"KEY6\":[1,2,3]}\r\n]]\r\n","prefix":"json.encode()"},"load":{"body":"load(${0:...})","description":"load (func [, chunkname])","prefix":"load"},"loadfile":{"body":"loadfile(${0:...})","description":"loadfile ([filename])","prefix":"loadfile"},"loadstring":{"body":"loadstring(${0:...})","description":"loadstring (string [, chunkname])","prefix":"loadstring"},"local":{"body":"local ${1:x} = ${0:1}","description":"local x = 1","prefix":"local"},"math.abs":{"body":"math.abs( ${1:x} )","description":"math.abs","prefix":"math.abs"},"math.abs()":{"body":"math.abs()","description":"计算绝对值\r\n返回值：\r\n  返回x的绝对值。","prefix":"math.abs()"},"math.acos":{"body":"math.acos( ${1:x} )","description":"math.acos","prefix":"math.acos"},"math.acos()":{"body":"math.acos()","description":"计算反余弦值\r\n返回值：\r\n  返回x的反余弦值（用弧度表示）。","prefix":"math.acos()"},"math.asin":{"body":"math.asin( ${1:x} )","description":"math.asin","prefix":"math.asin"},"math.asin()":{"body":"math.asin()","description":"计算反正弦值\r\n返回值：\r\n  返回x的反正弦值（用弧度表示）。","prefix":"math.asin()"},"math.atan":{"body":"math.atan( ${1:y}${2:[, x]} )","description":"math.atan","prefix":"math.atan"},"math.atan()":{"body":"math.atan()","description":"计算反正切值\r\n返回值：\r\n  返回 y/x 的反正切值（用弧度表示）。","prefix":"math.atan()"},"math.atan2":{"body":"math.atan2(${0:...})","description":"math.atan2 (y, x)","prefix":"math.atan2"},"math.ceil":{"body":"math.ceil( ${1:x} )","description":"math.ceil","prefix":"math.ceil"},"math.ceil()":{"body":"math.ceil()","description":"计算最小整数值\r\n返回值：\r\n  返回不小于 x 的最小整数值。","prefix":"math.ceil()"},"math.cos":{"body":"math.cos( ${1:x} )","description":"math.cos","prefix":"math.cos"},"math.cos()":{"body":"math.cos()","description":"计算余弦值\r\n返回值：\r\n  返回 x 的余弦","prefix":"math.cos()"},"math.cosh":{"body":"math.cosh(${0:...})","description":"math.cosh (x)","prefix":"math.cosh"},"math.deg":{"body":"math.deg( ${1:x} )","description":"math.deg","prefix":"math.deg"},"math.deg()":{"body":"math.deg()","description":"弧度转换为角度\r\n返回值：\r\n  返回转换后的角度值","prefix":"math.deg()"},"math.exp":{"body":"math.exp( ${1:x} )","description":"math.exp","prefix":"math.exp"},"math.exp()":{"body":"math.exp()","description":"计算 *ex* （*e*为自然对数的底 ）的值\r\n返回值：\r\n   *ex* （e 为自然对数的底 ）的值","prefix":"math.exp()"},"math.floor":{"body":"math.floor( ${1:x} )","description":"math.floor","prefix":"math.floor"},"math.floor()":{"body":"math.floor()","description":"计算不大于 x 的最大整数值。\r\n返回值：\r\n  返回不大于 x 的最大整数值。","prefix":"math.floor()"},"math.fmod":{"body":"math.fmod( ${1:x},${2:y} )","description":"math.fmod","prefix":"math.fmod"},"math.fmod()":{"body":"math.fmod()","description":"计算 x 除以 y，将商向零圆整后的余数\r\n返回值：\r\n  返回 x 除以 y，将商向零圆整后的余数。","prefix":"math.fmod()"},"math.frexp":{"body":"math.frexp(${0:...})","description":"math.frexp (x)","prefix":"math.frexp"},"math.huge":{"body":"math.huge","description":"浮点数 HUGE_VAL， 这个数比任何数字值都大。\r\n返回值：\r\n  无","prefix":"math.huge"},"math.ldexp":{"body":"math.ldexp(${0:...})","description":"math.ldexp (m, e)","prefix":"math.ldexp"},"math.log":{"body":"math.log( ${1:x}${2:[, base]} )","description":"math.log","prefix":"math.log"},"math.log()":{"body":"math.log()","description":"计算指定底的 x 的对数。 默认的 base 是 *e* （因此此函数返回 x 的自然对数）。\r\n返回值：\r\n  返回以指定底的 x 的对数","prefix":"math.log()"},"math.log10":{"body":"math.log10(${0:...})","description":"math.log10 (x)","prefix":"math.log10"},"math.math.randomseed":{"body":"math.math.randomseed( ${1:x} )","description":"math.math.randomseed","prefix":"math.math.randomseed"},"math.max":{"body":"math.max( ${1:x},${2:...} )","description":"math.max","prefix":"math.max"},"math.max()":{"body":"math.max()","description":"计算参数中最大的值， 大小由 Lua 操作 < 决定。\r\n返回值：\r\n  返回参数中最大的值","prefix":"math.max()"},"math.maxinteger":{"body":"math.maxinteger","description":"最大值的整数。\r\n返回值：\r\n  无","prefix":"math.maxinteger"},"math.min":{"body":"math.min( ${1:x},${2:...} )","description":"math.min","prefix":"math.min"},"math.min()":{"body":"math.min()","description":"返回参数中最小的值， 大小由 Lua 操作 < 决定。\r\n返回值：\r\n  返回参数中最小的值。","prefix":"math.min()"},"math.mininteger":{"body":"math.mininteger","description":"最小值的整数。\r\n返回值：\r\n  无","prefix":"math.mininteger"},"math.modf":{"body":"math.modf( ${1:x} )","description":"math.modf","prefix":"math.modf"},"math.modf()":{"body":"math.modf()","description":"计算 x 的整数部分和小数部分。\r\n返回值：\r\n  返回 x 的整数部分和小数部分。 第二个结果一定是浮点数。","prefix":"math.modf()"},"math.pi":{"body":"math.pi","description":"*π* 的值。\r\n返回值：\r\n  无","prefix":"math.pi"},"math.pow":{"body":"math.pow(${0:...})","description":"math.pow (x, y)","prefix":"math.pow"},"math.rad":{"body":"math.rad(${0:...})","description":"math.rad (x)","prefix":"math.rad"},"math.rad()":{"body":"math.rad()","description":"将角 x 从角度转换为弧度。\r\n返回值：\r\n  角 x 从角度转换为弧度值","prefix":"math.rad()"},"math.random":{"body":"math.random( ${1:[m]}${2:[, n]} )","description":"math.random","prefix":"math.random"},"math.random()":{"body":"math.random()","description":"随机数\r\n返回值：\r\n  当不带参数调用时， 返回一个 [0,1) 区间内一致分布的浮点伪随机数。 \r\n当以两个整数 m 与 n调用时， math.random返回一个 [m, n]区间 内一致分布的整数伪随机数。 （值 *m-n* 不能是负数，且必须在 Lua 整数的表示范围内。） \r\n调用 math.random(n) 等价于 math.random(1,n)。","prefix":"math.random()"},"math.randomseed":{"body":"math.randomseed(${0:...})","description":"math.randomseed (x)","prefix":"math.randomseed"},"math.randomseed()":{"body":"math.randomseed()","description":"把 x设为伪随机数发生器的“种子”： 相同的种子产生相同的随机数列。\r\n返回值：\r\n  无","prefix":"math.randomseed()"},"math.sin":{"body":"math.sin( ${1:x} )","description":"math.sin","prefix":"math.sin"},"math.sin()":{"body":"math.sin()","description":"计算x正弦值（假定参数是弧度）\r\n返回值：\r\n  返回 x 的正弦值","prefix":"math.sin()"},"math.sinh":{"body":"math.sinh(${0:...})","description":"math.sinh (x)","prefix":"math.sinh"},"math.sqrt":{"body":"math.sqrt( ${1:x} )","description":"math.sqrt","prefix":"math.sqrt"},"math.sqrt()":{"body":"math.sqrt()","description":"计算x平方根\r\n返回值：\r\n  返回 x 的平方根。","prefix":"math.sqrt()"},"math.tan":{"body":"math.tan( ${1:x} )","description":"math.tan","prefix":"math.tan"},"math.tan()":{"body":"math.tan()","description":"计算 x 的正切值，（假定参数是弧度）\r\n返回值：\r\n  返回 x 的正切值","prefix":"math.tan()"},"math.tanh":{"body":"math.tanh(${0:...})","description":"math.tanh (x)","prefix":"math.tanh"},"math.tointeger":{"body":"math.tointeger( ${1:x} )","description":"math.tointeger","prefix":"math.tointeger"},"math.tointeger()":{"body":"math.tointeger()","description":"将参数转换为整数\r\n返回值：\r\n  如果 x可以转换为一个整数， 返回该整数。 否则返回 nil。","prefix":"math.tointeger()"},"math.type":{"body":"math.type( ${1:x} )","description":"math.type","prefix":"math.type"},"math.type()":{"body":"math.type()","description":"判断数字类型\r\n返回值：\r\n  如果 x 是整数，返回 \"integer\"， 如果它是浮点数，返回 \"float\"， 如果 x 不是数字，返回 nil。","prefix":"math.type()"},"math.ult":{"body":"math.ult(${0:...})","description":"math.ult (m, n)","prefix":"math.ult"},"math.ult()":{"body":"math.ult()","description":"数值比较\r\n返回值：\r\n  整数 m 和 n 以无符号整数形式比较， m 在 n 之下，返回布尔真否则返回假。","prefix":"math.ult()"},"module":{"body":"module(${0:...})","description":"module (name [, ...])","prefix":"module"},"next":{"body":"next(${1:table}${2:[, index]})","description":"next (table [, index])","prefix":"next"},"os.clock":{"body":"os.clock(${0:...})","description":"os.clock ()","prefix":"os.clock"},"os.date":{"body":"os.date(${0:...})","description":"os.date ([format [, time]])","prefix":"os.date"},"os.difftime":{"body":"os.difftime(${0:...})","description":"os.difftime (t2, t1)","prefix":"os.difftime"},"os.execute":{"body":"os.execute(${0:...})","description":"os.execute ([command])","prefix":"os.execute"},"os.exit":{"body":"os.exit(${0:...})","description":"os.exit ([code])","prefix":"os.exit"},"os.getenv":{"body":"os.getenv(${0:...})","description":"os.getenv (varname)","prefix":"os.getenv"},"os.remove":{"body":"os.remove(${0:...})","description":"os.remove (filename)","prefix":"os.remove"},"os.rename":{"body":"os.rename(${0:...})","description":"os.rename (oldname, newname)","prefix":"os.rename"},"os.setlocale":{"body":"os.setlocale(${0:...})","description":"os.setlocale (locale [, category])","prefix":"os.setlocale"},"os.time":{"body":"os.time(${0:...})","description":"os.time ([table])","prefix":"os.time"},"os.tmpname":{"body":"os.tmpname(${0:...})","description":"os.tmpname ()","prefix":"os.tmpname"},"pack.pack()":{"body":"pack.pack()","description":"打包字符串的值,在pack的时候有符号 无符号的输出结果都是一样的 unpack时有符号跟无符号才有区别\r\n返回值：\r\n  一个包含所有格式化变量的字符串\r\n例子：\r\nprint(\"pcak.pack test：\")\r\nprint(pack.pack(\"A\",10))--当\"10\"以字符串形式包装时，会打印出“10”\r\nprint(common.binstohexs(pack.pack(\"b\",0x10)))--将0x01以十六进制打包为字符串，然后用十六进制输出0x10\r\nprint(pack.pack(\"A\",\"LUAT\"))\r\n","prefix":"pack.pack()"},"pack.unpack()":{"body":"pack.unpack()","description":"解包字符串\r\n返回值：\r\n  nextpos,字符串标记的位置\r\nval1,第一个解包的值\r\nval2,第二个解包的值\r\nvaln,第n个解包的值\r\n例子：\r\nprint(\"pack.unpack test:\")\r\nnextpox1,val1,val2,val3,val4=pack.unpack(\"luat100\",\"c4\")--\"nextpos\"下个待解析的位置\t，取4个字符(char)\r\nprint(nextpox1,val1,val2,val3,val4)        --分别对应的是\"5\"，l\",\"u\",\"a\",\"t\"的ascii码数据\r\nprint(string.char(val1,val2,val3,val4))    --将ascii码数据转化为字符输出\r\nnextpox2,string1=pack.unpack(\"luat100\",\"A4\")--输出“luat”\r\nprint(nextpox2,string1)--输出5 luat\r\nnextpox3,number1,number2=pack.unpack(common.hexstobins(\"006400000064\"),\">H>i\")--[[输出无符号短型和整形,因为无符号短型是2个字节，整形是4个字节,输出为100,100--]]\r\nprint(nextpox3,number1,number2)--输出7 100 100\r\nnextpox3,number1=pack.unpack(common.hexstobins(\"0064\"),\">h\")--输出为100，因为短型是2个字节\r\nprint(nextpox3,number1)--输出3 100\r\n","prefix":"pack.unpack()"},"package.config":{"body":"package.config(${0:...})","description":"package.config","prefix":"package.config"},"package.cpath":{"body":"package.cpath(${0:...})","description":"package.cpath","prefix":"package.cpath"},"package.loaded":{"body":"package.loaded(${0:...})","description":"package.loaded","prefix":"package.loaded"},"package.loaders":{"body":"package.loaders(${0:...})","description":"package.loaders","prefix":"package.loaders"},"package.loadlib":{"body":"package.loadlib(${0:...})","description":"package.loadlib (libname, funcname)","prefix":"package.loadlib"},"package.path":{"body":"package.path(${0:...})","description":"package.path","prefix":"package.path"},"package.preload":{"body":"package.preload(${0:...})","description":"package.preload","prefix":"package.preload"},"package.searchers":{"body":"package.searchers(${0:...})","description":"package.searchers","prefix":"package.searchers"},"package.searchpath":{"body":"package.searchpath(${0:...})","description":"package.searchpath (name, path [, sep [, rep]])","prefix":"package.searchpath"},"package.seeall":{"body":"package.seeall(${0:...})","description":"package.seeall (module)","prefix":"package.seeall"},"pairs":{"body":"pairs(${0:...})","description":"pairs (t)","prefix":"pairs"},"pcall":{"body":"pcall(${0:...})","description":"pcall (f, arg1, ...)","prefix":"pcall"},"pio.pin.getval()":{"body":"pio.pin.getval()","description":"读取管脚的值\r\n返回值：\r\n  number类型，0表示低电平，1表示高电平","prefix":"pio.pin.getval()"},"pio.pin.setdebounce()":{"body":"pio.pin.setdebounce()","description":"配置IO口消抖时间\r\n返回值：\r\n  无\r\n例子：\r\npio.pin.setdebounce(20)  --延时消抖设置为20ms\r\npio.pin.setdebounce(5)  --延时消抖设置为5ms\r\npio.pin.setdebounce(0)  --关闭延时消抖功能\r\n","prefix":"pio.pin.setdebounce()"},"pio.pin.setdir()":{"body":"pio.pin.setdir()","description":"设置管脚的描述\r\n返回值：\r\n  无","prefix":"pio.pin.setdir()"},"pio.pin.sethigh()":{"body":"pio.pin.sethigh()","description":"设置管脚为高电平(1)\r\n返回值：\r\n  无","prefix":"pio.pin.sethigh()"},"pio.pin.setlow()":{"body":"pio.pin.setlow()","description":"设置管脚为低电平(0)\r\n返回值：\r\n  无","prefix":"pio.pin.setlow()"},"pio.pin.setpull()":{"body":"pio.pin.setpull()","description":"配置IO口默认状态\r\n返回值：\r\n  无\r\n例子：\r\npio.pin.setpull(pio.PULLUP,pio.P0_5)  --配置为上拉\r\n--pio.pin.setpull(pio.PULLDOWN,pio.P0_5)  --配置为下拉\r\n--pio.pin.setpull(pio.NOPULL,pio.P0_5)  --不配置上下拉\r\n","prefix":"pio.pin.setpull()"},"pio.pin.setval()":{"body":"pio.pin.setval()","description":"设置管脚的值\r\n返回值：\r\n  无","prefix":"pio.pin.setval()"},"pmd.init()":{"body":"pmd.init()","description":"设置电源管理参数 <br>\r\n返回值：\r\n  1:成功\r\n0:失败","prefix":"pmd.init()"},"pmd.ldoset()":{"body":"pmd.ldoset()","description":"ldo 控制\r\n返回值：\r\n  无\r\n例子：\r\n--GPIO8输出电平时，要求输出2.8V，则调用\r\npmd.ldoset(5,pmd.LDO_VMMC)\r\n","prefix":"pmd.ldoset()"},"pmd.sleep()":{"body":"pmd.sleep()","description":"省电控制\r\n返回值：\r\n  无","prefix":"pmd.sleep()"},"print":{"body":"print(${1:...})","description":"print(...)","prefix":"print"},"qrencode.encode ()":{"body":"qrencode.encode ()","description":"创建二维码信息\r\n返回值：\r\n  width 生成的二维码信息宽度 \r\n\r\n例子：\r\n local width, data = qrencode.encode(\"http://www.openluat.com\")\r\n","prefix":"qrencode.encode ()"},"require":{"body":"require\"${1:module}\"","description":"require()","prefix":"require"},"ret":{"body":"return ${1:...}","description":"return ...","prefix":"ret"},"rtos.get_env_usage()":{"body":"rtos.get_env_usage()","description":"获取 lua 任务消息队列的使用百分比\r\n返回值：\r\n  percentage，百分比，例如使用了 80%，则 percentage 为 80","prefix":"rtos.get_env_usage()"},"rtos.get_fs_free_size()":{"body":"rtos.get_fs_free_size()","description":"获取文件系统剩余空间\r\n返回值：\r\n  文件系统剩余空间，单位Bytes","prefix":"rtos.get_fs_free_size()"},"rtos.make_dir()":{"body":"rtos.make_dir()","description":"创建目录\r\n返回值：\r\n  布尔值\r\ntrue表示创建成功，false表示失败","prefix":"rtos.make_dir()"},"rtos.poweroff()":{"body":"rtos.poweroff()","description":"软件关机\r\n返回值：\r\n  无","prefix":"rtos.poweroff()"},"rtos.poweron()":{"body":"rtos.poweron()","description":"是否启动 GSM 开机\r\n返回值：\r\n  无","prefix":"rtos.poweron()"},"rtos.poweron_reason()":{"body":"rtos.poweron_reason()","description":"读取开机原因值\r\n返回值：\r\n  rtos. POWERON_KEY(=0),按键开机\r\nrtos. POWERON_CHARGER(=1),充电开机\r\nrtos. POWERON_ALARM(=2),闹钟开机\r\nrtos. POWERON_RESTART(=3),软件重启开机\r\nrtos. POWERON_EXCEPTION(=6),异常开机\r\nrtos. POWERON_HOST(=7),HOST 工具控制重启开机\r\nrtos. POWERON_WATCHDOG(=8),其他原因","prefix":"rtos.poweron_reason()"},"rtos.receive()":{"body":"rtos.receive()","description":"接收消息\r\n返回值：\r\n  如果 msg 为 table 类型，msg 根据不同的消息 msg.id 会有不同的数据：\r\n如果 msg 为 number 类型，msg 根据不同的消息 msg 会有不同的数据\r\n1.rtos.MSG_TIMER 定时器超时消息\r\nmsg.timer_id 或者 msgpara 为超时的定时器 id\r\n2.rtos.MSG_UART_RXDATA 串口 ATC 数据提醒\r\nmsg.uart_id 或者msgpara为收到的数据的串口id或者atc,收到该消息后可以通过uart.read\r\n接口读取数据\r\n3.rtos.MSG_KEYPAD 键盘消息,必须初始化按键(#rtos.init_module#)后才会有键盘消息\r\nmsg.pressed 按键按下/弹起\r\nmsg.key_matrix_row 按键所在行值\r\nmsg.key_matrix_col 按键所在列值\r\n4.rtos.WAIT_MSG_TIMEOUT 等待消息超时\r\n5.rtos.MSG_INT 中断消息\r\nmsg.int_id 中断 id\r\nmsg.int_resnum 中断 pin 脚编号\r\n6.rtos.MSG_PMD 电源管理消息\r\nmsg.present 电池在位状态\r\nmsg.level 百分比 0-100\r\nmsg.voltage 电池电压\r\nmsg.charger 充电器在位状态\r\nmsg.state 充电状态:0-不在充电 1-充电中 2-充电停止","prefix":"rtos.receive()"},"rtos.remove_dir()":{"body":"rtos.remove_dir()","description":"删除文件夹\r\n返回值：\r\n  true表示删除成功，false表示失败","prefix":"rtos.remove_dir()"},"rtos.restart()":{"body":"rtos.restart()","description":"软件重启\r\n返回值：\r\n  无","prefix":"rtos.restart()"},"rtos.set_alarm()":{"body":"rtos.set_alarm()","description":"设置闹钟，在设置之前必须注册闹钟模块和注册消息回调函数\r\n返回值：\r\n  无\r\n例子：\r\nrtos.init_module(rtos.MOD_ALARM) --注册闹铃模块\r\nsys.regmsg(rtos.MSG_ALARM,alarmmsg) --注册消息回调函数\r\nrtos.set_alarm(1, 2017, 12, 7, 10, 52, 0) --设置闹铃\r\n--闹钟时间 2017-17-7 10:52:0\r\nrtos.set_alarm(0, 0, 0, 0, 0, 0, 0)  --关闭闹铃\r\n\r\n--闹钟开机\r\nlocal reason = rtos.poweron_reason()\r\nif reason == rtos.POWERON_ALARM then\r\n\trtos.restart()-- 闹钟开机以后重启不然注册不上GSM协议栈\r\nend\r\n\r\n","prefix":"rtos.set_alarm()"},"rtos.sleep()":{"body":"rtos.sleep()","description":"延时函数\r\n返回值：\r\n  无","prefix":"rtos.sleep()"},"rtos.tick()":{"body":"rtos.tick()","description":"获取系统开机运行时间总计数\r\n返回值：\r\n  ticks，时间计数，每 tick 时长1/16384秒","prefix":"rtos.tick()"},"rtos.timer_start()":{"body":"rtos.timer_start()","description":"启动定时器\r\n返回值：\r\n  无","prefix":"rtos.timer_start()"},"rtos.timer_stop()":{"body":"rtos.timer_stop()","description":"停止定时器\r\n返回值：\r\n  无","prefix":"rtos.timer_stop()"},"select":{"body":"select(${1:index}, ${2:...})","description":"select (index, ···)","prefix":"select"},"setfenv":{"body":"setfenv(${0:...})","description":"setfenv (f, table)","prefix":"setfenv"},"setmetatable":{"body":"setmetatable(${1:table}, ${2:metatable})","description":"setmetatable (table, metatable)","prefix":"setmetatable"},"spi.close()":{"body":"spi.close()","description":"关闭SPI\r\n返回值：\r\n  number类型，1表示成功，0表示失败","prefix":"spi.close()"},"spi.recv()":{"body":"spi.recv()","description":"读数据\r\n返回值：\r\n  string类型，读取的数据内容","prefix":"spi.recv()"},"spi.send()":{"body":"spi.send()","description":"写数据\r\n返回值：\r\n  number类型，写成功的数据长度","prefix":"spi.send()"},"spi.send_recv()":{"body":"spi.send_recv()","description":"读写数据\r\n返回值：\r\n  string类型，读取的数据内容","prefix":"spi.send_recv()"},"spi.setup":{"body":"spi.setup","description":"- 语法\r\n返回值：\r\n  number类型，1表示成功，0表示失败","prefix":"spi.setup"},"string.byte()":{"body":"string.byte()","description":"接收控制字符，返回ASCII码\r\n返回值：\r\n  ASCII码\r\n例子：\r\nstring.byte(\"ABCD\")  --65\r\nstring.byte(\"ABCD\",4) --68\r\n","prefix":"string.byte()"},"string.char()":{"body":"string.char()","description":"接收ASCII码，返回对应的控制字符\r\n返回值：\r\n  字符\r\n例子：\r\nstring.char(97,98,99,100)   --abcd\r\n","prefix":"string.char()"},"string.find()":{"body":"string.find()","description":"查找第一个字符串 s 中匹配到的 pattern\r\n返回值：\r\n  返回匹配字符具体位置。不存在则返回 nil\r\n例子：\r\nstring.find(\"Hello Lua user\", \"Lua\", 1)   --7   9\r\n","prefix":"string.find()"},"string.format()":{"body":"string.format()","description":"格式化字符串\r\n返回值：\r\n  字符串\r\n例子：\r\nstring.format(\"the value is:%d\",4)   --the value is:4\r\n","prefix":"string.format()"},"string.gsub()":{"body":"string.gsub()","description":"字符串替换","prefix":"string.gsub()"},"string.len()":{"body":"string.len()","description":"计算字符串长度\r\n返回值：\r\n  字符串长度\r\n例子：\r\nstring.len(\"abc\")  --3\r\n","prefix":"string.len()"},"string.lower()":{"body":"string.lower()","description":"字符串全部转为小写字母\r\n返回值：\r\n  小写字母字符串","prefix":"string.lower()"},"string.rep()":{"body":"string.rep()","description":"字符串拷贝\r\n返回值：\r\n  字符串\r\n例子：\r\nstring.rep(\"abcd\",2)   --abcdabcd\r\n","prefix":"string.rep()"},"string.reverse()":{"body":"string.reverse()","description":"字符串反转\r\n返回值：\r\n  反转后的字符串\r\n例子：\r\nstring.reverse(\"Luat\")  --tauL\r\n","prefix":"string.reverse()"},"string.upper()":{"body":"string.upper()","description":"字符串全部转为大写字母\r\n返回值：\r\n  大写字母字符串","prefix":"string.upper()"},"table.concat()":{"body":"table.concat()","description":"表连接\r\n返回值：\r\n  字符串\r\n例子：\r\nfruits = {\"banana\",\"orange\",\"apple\"}\r\n-- 返回 table 连接后的字符串\r\nprint(\"连接后的字符串 \",table.concat(fruits))\r\n--连接后的字符串     bananaorangeapple\r\n\r\n-- 指定连接字符\r\nprint(\"连接后的字符串 \",table.concat(fruits,\", \"))\r\n--连接后的字符串     banana, orange, apple\r\n\r\n-- 指定索引来连接 table\r\nprint(\"连接后的字符串 \",table.concat(fruits,\", \", 2,3))\r\n--连接后的字符串     orange, apple\r\n","prefix":"table.concat()"},"table.insert()":{"body":"table.insert()","description":"添加table参数\r\n返回值：\r\n  table\r\n例子：\r\nfruits = {\"banana\",\"orange\",\"apple\"}\r\n\r\n-- 在末尾插入\r\ntable.insert(fruits,\"mango\")\r\nprint(\"索引为 4 的元素为 \",fruits[4])\r\n--索引为 4 的元素为     mango\r\n\r\n-- 在索引为 2 的键处插入\r\ntable.insert(fruits,2,\"grapes\")\r\nprint(\"索引为 2 的元素为 \",fruits[2])\r\n--索引为 2 的元素为     grapes\r\n\r\nprint(\"最后一个元素为 \",fruits[5])\r\n--最后一个元素为     mango\r\n","prefix":"table.insert()"},"table.remove()":{"body":"table.remove()","description":"移除table参数\r\n返回值：\r\n  table","prefix":"table.remove()"},"tonumber":{"body":"tonumber(${1:e}${2:[, base]})","description":"tonumber (e [, base])","prefix":"tonumber"},"tostring":{"body":"tostring(${1:v})","description":"tostring (v)","prefix":"tostring"},"type":{"body":"type(${1:v})","description":"type (v)","prefix":"type"},"uart.close()":{"body":"uart.close()","description":"关闭 uart 接口\r\n返回值：\r\n  无","prefix":"uart.close()"},"uart.getchar()":{"body":"uart.getchar()","description":"从串口读取单字符\r\n返回值：\r\n  串口读出来的字符","prefix":"uart.getchar()"},"uart.read()":{"body":"uart.read()","description":"从串口读取字符串\r\n返回值：\r\n  串口读出到的数据","prefix":"uart.read()"},"uart.set_rs485_oe()":{"body":"uart.set_rs485_oe()","description":"* 语法\r\n返回值：\r\n    无\r\n例子：\r\nuart.setup(UART_ID,115200,8,uart.PAR_NONE,uart.STOP_1,nil,1) --必须先使用setup，并且最后一个参数是1（打开发送完成后的通知功能）\r\nuart.set_rs485_oe(UART_ID, pio.P2_0) --仅4G 0013版本之后支持\r\n\r\n","prefix":"uart.set_rs485_oe()"},"uart.setup()":{"body":"uart.setup()","description":"uart通讯\r\n返回值：\r\n  串口的真实波特率","prefix":"uart.setup()"},"uart.write()":{"body":"uart.write()","description":"向串口写字符串或者整型数据\r\n返回值：\r\n  无","prefix":"uart.write()"},"unpack":{"body":"unpack(${0:...})","description":"unpack (list [, i [, j]])","prefix":"unpack"},"xpcall":{"body":"xpcall(${0:...})","description":"xpcall (f, err)","prefix":"xpcall"}}